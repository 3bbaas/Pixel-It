{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-pixel-it","title":"Welcome to Pixel-It","text":"<p>For full project source codes visit Pixel-It.</p>"},{"location":"#description","title":"Description","text":"<p>Pixel It is a lightweight C# WinForms image-editor that lets you apply filters-brightness, contrast, blur, oil-painting, negative, grayscale, metadata viewing/clearing, and more-to any bitmap. It\u2019s perfect for quick, pixel-level edits without the weight of a full graphics suite.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Demo</li> <li>Features</li> <li>Installation</li> <li>Usage</li> <li>Configuration</li> <li>Project Layout</li> <li>Contributing</li> <li>License</li> </ol>"},{"location":"#demo","title":"Demo","text":""},{"location":"#features","title":"Features","text":"<ul> <li> <p>Core Filters: Brightness, Contrast, Gaussian Blur, Uniform Blur, Sobel Edge Detect, Invert (Negative), Grayscale </p> </li> <li> <p>Artistic Effects: Oil Painting, Pixelate, Posterize </p> </li> <li> <p>Metadata Tools: View and clear EXIF metadata from JPEGs </p> </li> <li> <p>UI Controls: Fit-to-PictureBox, Zoom In/Out, Undo/Redo, Crop </p> </li> <li> <p>File I/O: Save As (JPEG/PNG/BMP/GIF/TIFF), Batch-save in multiple formats, Compression quality slider </p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Clone the repo <pre><code>git clone https://github.com/3bbaas/Pixel-It.git\ncd pixel_it\n</code></pre></li> <li>Open in Visual Studio 2019+ (requires .NET 5/6).</li> <li>Restore NuGet packages, including [MetadataExtractor] for EXIF</li> <li>Build &amp; Run the Pixel_It project.</li> </ol>"},{"location":"#usage","title":"Usage","text":"<ol> <li>Load an image via File  Open.</li> <li>Select a filter from the toolbar (e.g., Brightness, Contrast).</li> <li>Adjust parameters with trackbars or numeric fields.</li> <li>Preview updates in real time (Fit/Zoom controls available).</li> <li>Apply to commit or Cancel to revert.</li> <li>Save As to write out the edited bitmap.</li> </ol>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>JPEG Quality: Default 90%; adjustable in the Compress dialog.</li> <li>Undo Depth: Unlimited snapshots via Memento pattern (configurable in code).  </li> <li>Metadata Columns: Defined in <code>MetaData</code> form\u2019s <code>ListView</code> columns.  </li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>Pixel-It:\n\n\u251c\u2500\u2500\u2500.github\n\u2502   \u2514\u2500\u2500\u2500workflows\n\u251c\u2500\u2500\u2500docs        # docs directory.\n\u2502   \u2514\u2500\u2500\u2500 ... \n\u251c\u2500\u2500\u2500Pixel-It\n\u2502       About.cs\n\u2502       About.Designer.cs\n\u2502       About.resx\n\u2502       App.config\n\u2502       Blur.cs\n\u2502       Blur.Designer.cs\n\u2502       Blur.resx\n\u2502       Brightness.cs\n\u2502       Brightness.Designer.cs\n\u2502       Brightness.resx\n\u2502       Compress.cs\n\u2502       Compress.Designer.cs\n\u2502       Compress.resx\n\u2502       Contrast.cs\n\u2502       Contrast.Designer.cs\n\u2502       Contrast.resx\n\u2502       Convert_To_R_G_B.cs\n\u2502       Convert_To_R_G_B.Designer.cs\n\u2502       Convert_To_R_G_B.resx\n\u2502       DoubleBufferDisplay.cs\n\u2502       DoubleBufferDisplay.Designer.cs\n\u2502       DoubleBufferDisplay.resx\n\u2502       FilterPreview.cs\n\u2502       FilterPreview.resx\n\u2502       Form1.cs\n\u2502       Form1.Designer.cs\n\u2502       Form1.resx\n\u2502       Gamma.cs\n\u2502       Gamma.Designer.cs\n\u2502       Gamma.resx\n\u2502       GaussianBlur.cs\n\u2502       GaussianBlur.Designer.cs\n\u2502       GaussianBlur.resx\n\u2502       GetHistogram.cs\n\u2502       Greyscale.cs\n\u2502       Greyscale.Designer.cs\n\u2502       Greyscale.resx\n\u2502       harrow.cur\n\u2502       Histogram.cs\n\u2502       Histogram.Designer.cs\n\u2502       Histogram.resx\n\u2502       hmove.cur\n\u2502       MetaData.cs\n\u2502       MetaData.Designer.cs\n\u2502       MetaData.resx\n\u2502       Negative.cs\n\u2502       Negative.Designer.cs\n\u2502       Negative.resx\n\u2502       OilPainting.cs\n\u2502       OilPainting.Designer.cs\n\u2502       OilPainting.resx\n\u2502       packages.config\n\u2502       Pixel-It.csproj\n\u2502       Pixel_it app icon.ico\n\u2502       Program.cs\n\u2502       Sobel.cs\n\u2502    \n\u251c\u2500\u2500\u2500Aforge/            # The Aforge.Net DLLs folder.\n\u2502       AForge.Controls.dll\n\u2502       AForge.dll\n\u2502       AForge.Imaging.dll\n\u2502       AForge.Math.dll\n\u2502\n\u2514\u2500\u2500\u2500assets/             # The assets folder.\n        app-about-icon.png\n        flip_horizontal.png\n        ...\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome pull requests!  </p> <ol> <li>Fork the repo  </li> <li>Create your feature branch (<code>git checkout -b feature/XYZ</code>)  </li> <li>Commit your changes (<code>git commit -m \"Add XYZ\"</code>)  </li> <li>Push (<code>git push origin feature/XYZ</code>)  </li> <li>Open a Pull Request  </li> </ol>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See LICENSE for details.</p>"},{"location":"About/","title":"About","text":""},{"location":"About/#about-project","title":"About Project","text":""},{"location":"About/#why-pixel-it","title":"Why Pixel-It?","text":""},{"location":"About/#coming-soon","title":"Coming Soon!","text":""},{"location":"About/#project-developers","title":"Project Developers","text":"<ul> <li> <p> Ahmed Mohamed Abbas</p> <p></p> <p> <code>Resume</code></p> <p> <code>AI</code>, <code>Backend Dev</code>.</p> <p> Connect &amp; Follow :  </p> </li> <li> <p> Hassnaa Nageh</p> <p></p> <p> <code>Resume</code></p> <p> <code>Frontend Dev</code>.</p> <p> Connect &amp; Follow :  </p> </li> <li> <p> Ahmed Ibrahim</p> <p></p> <p> <code>Resume</code></p> <p> <code>FLutter</code>, <code>AI</code>.</p> <p> Connect &amp; Follow :  </p> </li> <li> <p> Rokiya Abdelsattar</p> <p></p> <p> <code>Resume</code></p> <p> <code>AI</code>, <code>Embedded</code>, <code>Flutter</code>.</p> <p> Connect &amp; Follow :  </p> </li> <li> <p> Seif Eldien Mohamed</p> <p></p> <p> <code>Resume</code></p> <p> <code>Data Analyst</code>.</p> <p> Connect &amp; Follow :  </p> </li> </ul>"},{"location":"Filters/blur/","title":"Blur","text":""},{"location":"Filters/blur/#blur-uniform-blur","title":"Blur (Uniform Blur)","text":""},{"location":"Filters/blur/#what-it-does","title":"What it does","text":"<p>The Blur filter applies a simple <code>3\u00d73</code> averaging kernel (each weight = 1/9) around every pixel, smoothing out noise and softening edges.</p>"},{"location":"Filters/blur/#preview","title":"Preview","text":"Uniform Blur Preview"},{"location":"Filters/blur/#usage-in-code","title":"Usage in Code","text":"Blur.cs<pre><code>private int Clamp(int value)\n{\n    return Math.Max(0, Math.Min(255, value));\n}\n\nprivate Bitmap ApplyBlurFilter(Bitmap sourceImage)\n{\n    Bitmap newImage = new Bitmap(sourceImage.Width, sourceImage.Height);\n\n    float[,] kernel = {\n        { 1f/9f, 1f/9f, 1f/9f },\n        { 1f/9f, 1f/9f, 1f/9f },\n        { 1f/9f, 1f/9f, 1f/9f }\n    };\n\n    int width  = sourceImage.Width;\n    int height = sourceImage.Height;\n\n    for (int x = 1; x &lt; width - 1; x++)\n    for (int y = 1; y &lt; height - 1; y++)\n    {\n        float r = 0, g = 0, b = 0;\n\n        // Convolution\n        for (int ky = -1; ky &lt;= 1; ky++)\n        for (int kx = -1; kx &lt;= 1; kx++)\n        {\n            Color p = sourceImage.GetPixel(x + kx, y + ky);\n            float w = kernel[ky + 1, kx + 1];\n            r += p.R * w;\n            g += p.G * w;\n            b += p.B * w;\n        }\n\n        int a = sourceImage.GetPixel(x, y).A;\n        Color nc = Color.FromArgb(a,\n            Clamp((int)r),\n            Clamp((int)g),\n            Clamp((int)b)\n        );\n        newImage.SetPixel(x, y, nc);\n    }\n\n    return newImage;\n}\n</code></pre> <p>Blur</p> <p>Uniform blur is fast but can produce \u201cboxy\u201d artifacts. For a softer fall-off, see Gaussian Blur.</p>"},{"location":"Filters/brightness/","title":"Brightness","text":""},{"location":"Filters/brightness/#brightness","title":"Brightness","text":""},{"location":"Filters/brightness/#what-it-does","title":"What it does","text":"<p>The Brightness filter simply adds (or subtracts) a constant value to each pixel\u2019s R, G, and B channels, making the image overall lighter or darker.</p>"},{"location":"Filters/brightness/#preview","title":"Preview","text":"Brightness Filter Preview"},{"location":"Filters/brightness/#usage-in-code","title":"Usage in Code","text":"Brightness.cs<pre><code>private int Clamp(int value)\n{\n    return Math.Max(0, Math.Min(255, value));\n}\nprivate Bitmap ApplyBrightnessFilter(Bitmap sourceImage, int brightness)\n{\n    Bitmap newImage = new Bitmap(sourceImage.Width, sourceImage.Height);\n\n    for (int x = 0; x &lt; sourceImage.Width; x++)\n    {\n        for (int y = 0; y &lt; sourceImage.Height; y++)\n        {\n            Color pixel = sourceImage.GetPixel(x, y);\n\n            int r = Clamp(pixel.R + brightness);\n            int g = Clamp(pixel.G + brightness);\n            int b = Clamp(pixel.B + brightness);\n\n            Color newColor = Color.FromArgb(r, g, b);\n            newImage.SetPixel(x, y, newColor);\n        }\n    }\n\n    return newImage;\n}\n</code></pre>"},{"location":"Filters/contrast/","title":"Contrast","text":""},{"location":"Filters/contrast/#contrast","title":"Contrast","text":""},{"location":"Filters/contrast/#what-it-does","title":"What it does","text":"<p>The Contrast filter increases the difference between dark and light areas by scaling each color channel around the midpoint (128). Positive values boost contrast, negative values reduce it.</p>"},{"location":"Filters/contrast/#preview","title":"Preview","text":"Contrast Filter Preview"},{"location":"Filters/contrast/#usage-in-code","title":"Usage in Code","text":"Contrast.cs<pre><code>private int Clamp(int value)\n{\n    return Math.Max(0, Math.Min(255, value));\n}\n\nprivate Bitmap ApplyContrastFilter(Bitmap sourceImage, int contrast)\n{\n    Bitmap newImage = new Bitmap(sourceImage.Width, sourceImage.Height);\n    double factor = 259.0 * (contrast + 255.0) / (255.0 * (259.0 - contrast));\n\n    for (int x = 0; x &lt; sourceImage.Width; x++)\n    for (int y = 0; y &lt; sourceImage.Height; y++)\n    {\n        Color p = sourceImage.GetPixel(x, y);\n\n        int r = Clamp((int)(factor * (p.R - 128) + 128));\n        int g = Clamp((int)(factor * (p.G - 128) + 128));\n        int b = Clamp((int)(factor * (p.B - 128) + 128));\n\n        newImage.SetPixel(x, y, Color.FromArgb(p.A, r, g, b));\n    }\n\n    return newImage;\n}\n</code></pre>"},{"location":"Filters/gamma/","title":"Gamma","text":""},{"location":"Filters/gamma/#gamma-correction","title":"Gamma Correction","text":""},{"location":"Filters/gamma/#what-it-does","title":"What it does","text":"<p>Adjusts each color channel non-linearly via a power-law (<code>output = 255 \u00d7 (input/255)^(1/\u03b3)</code>), brightening or darkening midtones without clipping highlights/shadows.</p>"},{"location":"Filters/gamma/#preview","title":"Preview","text":"Gamma adjustments at \u03b3=0.5 (brighter) and \u03b3=2.0 (darker)"},{"location":"Filters/gamma/#usage-in-code","title":"Usage in Code","text":"Gamma.cs<pre><code>private int Clamp(int v) =&gt; Math.Max(0, Math.Min(255, v));\n\nprivate Bitmap ApplyGammaFilter(Bitmap sourceImage, double gamma)\n{\n    int width = sourceImage.Width;\n    int height = sourceImage.Height;\n    Bitmap newImage = new Bitmap(width, height);\n\n    for (int x = 0; x &lt; width; x++)\n    {\n        for (int y = 0; y &lt; height; y++)\n        {\n            Color px = sourceImage.GetPixel(x, y);\n            double r = Math.Pow(px.R / 255.0, 1.0 / gamma) * 255.0;\n            double g = Math.Pow(px.G / 255.0, 1.0 / gamma) * 255.0;\n            double b = Math.Pow(px.B / 255.0, 1.0 / gamma) * 255.0;\n\n            Color newColor = Color.FromArgb(\n                px.A,\n                Clamp((int)r),\n                Clamp((int)g),\n                Clamp((int)b)\n            );\n            newImage.SetPixel(x, y, newColor);\n        }\n    }\n\n    return newImage;\n}\n</code></pre> <p>Gamma (photography)</p> <p>In photography, gamma refers to the relationship between the input and output brightness levels of an image, often used to adjust the tonal range and contrast. A gamma correction modifies the brightness and contrast to compensate for the non-linear perception of light by human vision or display devices. <code>Wiki</code></p>"},{"location":"Filters/gaussian_blur/","title":"Gaussian Blur","text":""},{"location":"Filters/gaussian_blur/#gaussian-blur","title":"Gaussian Blur","text":""},{"location":"Filters/gaussian_blur/#what-it-does","title":"What it does","text":"<p>Smooths the image by convolving with a 3\u00d73 Gaussian kernel (<code>[1 2 1; 2 4 2; 1 2 1]/16</code>), giving a more natural, bell-shaped blur than uniform averaging.</p>"},{"location":"Filters/gaussian_blur/#preview","title":"Preview","text":"3\u00d73 Gaussian blur applied"},{"location":"Filters/gaussian_blur/#usage-in-code","title":"Usage in Code","text":"GaussianBlur.cs<pre><code>private int Clamp(int v) =&gt; Math.Max(0, Math.Min(255, v));\n\nprivate Bitmap ApplyGaussianBlur(Bitmap src)\n{\n    float[,] k = {\n        {1f/16, 2f/16, 1f/16},\n        {2f/16, 4f/16, 2f/16},\n        {1f/16, 2f/16, 1f/16}\n    };\n    int w = src.Width, h = src.Height;\n    Bitmap outBmp = new Bitmap(w, h);\n\n    for (int x = 1; x &lt; w-1; x++)\n    for (int y = 1; y &lt; h-1; y++)\n    {\n        float r=0, g=0, b=0;\n        for (int i=-1; i&lt;=1; i++)\n        for (int j=-1; j&lt;=1; j++)\n        {\n            Color p = src.GetPixel(x+i, y+j);\n            float wt = k[j+1,i+1];\n            r += p.R*wt; g += p.G*wt; b += p.B*wt;\n        }\n        Color np = Color.FromArgb(\n            src.GetPixel(x,y).A,\n            Clamp((int)r),\n            Clamp((int)g),\n            Clamp((int)b)\n        );\n        outBmp.SetPixel(x, y, np);\n    }\n    return outBmp;\n}\n</code></pre>"},{"location":"Filters/negative/","title":"Negative","text":""},{"location":"Filters/negative/#negative-invert-colors","title":"Negative (Invert Colors):","text":""},{"location":"Filters/negative/#what-it-does","title":"What it does","text":"<p>The Negative filter inverts every pixel\u2019s color by subtracting each RGB component from <code>255</code>, producing a photographic \u201cnegative\u201d effect. Bright areas become dark, and cool tones swap to warm tones.</p>"},{"location":"Filters/negative/#preview","title":"Preview","text":"Negative Filter Preview"},{"location":"Filters/negative/#usage-in-code","title":"Usage in Code","text":"Negative.cs<pre><code>private Bitmap ApplyNegativeFilter(Bitmap sourceImage)\n{\n    int width  = sourceImage.Width;\n    int height = sourceImage.Height;\n    Bitmap newImage = new Bitmap(width, height);\n\n    for (int x = 0; x &lt; width; x++)\n    {\n        for (int y = 0; y &lt; height; y++)\n        {\n            Color px = sourceImage.GetPixel(x, y);\n            // Invert each channel\n            int r = 255 - px.R;\n            int g = 255 - px.G;\n            int b = 255 - px.B;\n\n            Color inverted = Color.FromArgb(px.A, r, g, b);\n            newImage.SetPixel(x, y, inverted);\n        }\n    }\n\n    return newImage;\n}\n</code></pre> <p>Negative (photography)</p> <p>In photography, a negative is an image, usually on a strip or sheet of transparent plastic film, in which the lightest areas of the photographed subject appear darkest and the darkest areas appear lightest. <code>Wiki</code></p>"},{"location":"Filters/oil_painting/","title":"Oil Painting","text":""},{"location":"Filters/oil_painting/#oil-painting-effect","title":"Oil Painting Effect","text":""},{"location":"Filters/oil_painting/#what-it-does","title":"What it does","text":"<p>Simulates a painterly look by grouping neighborhood pixels by intensity, then replacing each pixel with the average color of the most frequent intensity bin in its brush-sized region.</p>"},{"location":"Filters/oil_painting/#preview","title":"Preview","text":"Oil painting with brush size = 5"},{"location":"Filters/oil_painting/#usage-in-code","title":"Usage in Code","text":"OilPainting.cs<pre><code>private Bitmap ApplyOilPaintingBrushSize(Bitmap source, int brushSize)\n{\n    const int intensityLevels = 30;\n\n    for (int x = 0; x &lt; width; x++)\n    for (int y = 0; y &lt; height; y++)\n    {\n        for (int nx = Math.Max(0, x - brushSize); nx &lt;= Math.Min(width - 1, x + brushSize); nx++)\n        {\n            for (int ny = Math.Max(0, y - brushSize); ny &lt;= Math.Min(height - 1, y + brushSize); ny++)\n            {\n                Color p = source.GetPixel(nx, ny);\n                int intensity = (int)(((p.R + p.G + p.B) / 3.0) * intensityLevels / 255.0);\n                if (intensity &gt;= intensityLevels) intensity = intensityLevels - 1;\n\n                count[intensity]++;\n                sumR[intensity] += p.R;\n                sumG[intensity] += p.G;\n                sumB[intensity] += p.B;\n            }\n        }\n\n        int maxCount = 0, bestIdx = 0;\n        for (int i = 0; i &lt; intensityLevels; i++)\n        {\n            if (count[i] &gt; maxCount)\n            {\n                maxCount = count[i];\n                bestIdx = i;\n            }\n        }\n\n        Color original = source.GetPixel(x, y);\n        int r = sumR[bestIdx] / maxCount;\n        int g = sumG[bestIdx] / maxCount;\n        int b = sumB[bestIdx] / maxCount;\n        result.SetPixel(x, y, Color.FromArgb(original.A, r, g, b));\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"Filters/sobel/","title":"Sobel Edge","text":""},{"location":"Filters/sobel/#sobel-edge-detection","title":"Sobel Edge Detection","text":""},{"location":"Filters/sobel/#what-it-does","title":"What it does","text":"<p>Detects edges by convolving a grayscale version of the image with horizontal and vertical Sobel kernels, then combining their magnitudes.</p>"},{"location":"Filters/sobel/#preview","title":"Preview","text":"Sobel filter highlighting edges"},{"location":"Filters/sobel/#usage-in-code","title":"Usage in Code","text":"Sobel.cs<pre><code>private int Clamp(int v) =&gt; Math.Max(0, Math.Min(255, v));\n\nint[,] gx = { { -1,0,1 }, { -2,0,2 }, { -1,0,1 } };\nint[,] gy = { {  1,2,1 }, {  0,0,0 }, { -1,-2,-1 } };\n\nprivate Bitmap ApplySobelFilter(Bitmap sourceImage)\n{\n    int width = sourceImage.Width;\n    int height = sourceImage.Height;\n    Bitmap grayImage = new Bitmap(width, height);\n    Bitmap edgeImage = new Bitmap(width, height);\n\n    for (int x = 0; x &lt; width; x++)\n    for (int y = 0; y &lt; height; y++)\n    {\n        Color px = sourceImage.GetPixel(x, y);\n        int l = (px.R + px.G + px.B) / 3;\n        grayImage.SetPixel(x, y, Color.FromArgb(px.A, l, l, l));\n    }\n\n\n    for (int x = 1; x &lt; width - 1; x++)\n    for (int y = 1; y &lt; height - 1; y++)\n    {\n        int sumX = 0, sumY = 0;\n\n        for (int ky = -1; ky &lt;= 1; ky++)\n        for (int kx = -1; kx &lt;= 1; kx++)\n        {\n            int pixel = grayImage.GetPixel(x + kx, y + ky).R;\n            sumX += gx[ky + 1, kx + 1] * pixel;\n            sumY += gy[ky + 1, kx + 1] * pixel;\n        }\n\n        int g = (int)Math.Sqrt(sumX * sumX + sumY * sumY);\n        g = Clamp(g);\n\n        edgeImage.SetPixel(x, y, Color.FromArgb(255, g, g, g));\n    }\n\n    return edgeImage;\n}\n</code></pre> <p>Sobel Filter</p> <p>The Sobel filter is an edge detection technique used in image processing and computer vision. It works by calculating the gradient of the image intensity at each pixel, highlighting regions of high spatial frequency that correspond to edges. The filter uses convolution with two 3x3 kernels to detect horizontal and vertical changes in intensity.</p>"},{"location":"View/colors/","title":"Channels","text":""},{"location":"View/colors/#color-channel-extractor","title":"Color Channel Extractor","text":""},{"location":"View/colors/#what-it-does","title":"What it does","text":"<p>Extracts a single color channel (Red, Green, or Blue) by zeroing out the other two. Useful for examining per-channel detail.</p>"},{"location":"View/colors/#preview","title":"Preview","text":"Red, Green, and Blue channel isolation"},{"location":"View/colors/#usage-in-code","title":"Usage in Code","text":"Convert_To_R_G_B.cs<pre><code>    public enum Colors { Red, Green, Blue};\n\n    public static class IMG\n    {\n        public static Bitmap GetColor(Bitmap src, Colors c)\n        {\n            int w = src.Width, h = src.Height;\n            Bitmap ret = new Bitmap(w, h);\n\n            for (int i = 0; i &lt; w; ++i)\n            for (int j = 0; j &lt; h; ++j)\n            {\n                Color pixel = src.GetPixel(i, j);\n                int r = 0, g = 0, b = 0;\n                if (c == Colors.Red) r = pixel.R; \n                else if (c == Colors.Green) g = pixel.G;\n                else if (c == Colors.Blue) b = pixel.B;\n\n                ret.SetPixel(i, j, Color.FromArgb(r, g, b));\n            }\n            return ret;\n        }\n</code></pre>"},{"location":"View/equalized_image/","title":"Image Equalization","text":""},{"location":"View/equalized_image/#equalized-image","title":"Equalized image","text":""},{"location":"View/equalized_image/#coming-soon","title":"Coming Soon","text":""},{"location":"View/histogram/","title":"Histogram","text":""},{"location":"View/histogram/#histogram","title":"Histogram","text":""},{"location":"View/histogram/#coming-soon","title":"Coming Soon!","text":""}]}